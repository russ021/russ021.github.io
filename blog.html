<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Linux Blog</title>
    <link rel="stylesheet" href="assets/styles.css">
</head>
<body>
    <header>
        <div class="container">
            <h1>My Linux Blog</h1>
            <nav>
                <ul>
                    <li><a href="index.html">Home</a></li>
                    <li><a href="about.html">About</a></li>
                    <li><a href="blog.html">Blog</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <main>
        <section id="home" class="hero">
            <div class="container">
                <h2>Switching to a Beginner-Friendly Linux Distro: A Guide for New Users - Jan.25.2025</h2>
                <p>Making the switch to Linux can be both exciting and overwhelming, especially if you're coming from Windows
                    or macOS. With so many distributions (distros) to choose from, picking the right one is crucial to
                    ensuring a smooth and frustration-free experience. Fortunately, there are several beginner-friendly Linux
                    distros that make the transition easier. In this guide, we'll explore why you should switch to Linux,
                    what to look for in a beginner-friendly distro, and some of the best options available.</p>
                
                <h1>Why Switch to Linux?</h1>
                <p>Linux is a powerful, secure, and customizable operating system that offers several advantages over
                    traditional operating systems like Windows and macOS:</p>

                <p>Free and Open Source - Most Linux distros are completely free, with no hidden costs or licenses.<br>
                    Security and Privacy - Linux is less vulnerable to malware and offers better privacy controls.
                    Performance and Stability - Linux runs efficiently on both old and new hardware, making it a great choice for
                    breathing new life into older computers.<br> 
                    Customization - From desktop environments to software choices, Linux allows
                    users to tailor their experience.<br>
                    Vast Community Support - With an active global community, help is always
                    available through forums, guides, and online resources.</p>
                
                <h1>What to Look for in a Beginner-Friendly Distro</h1>
                <p>For new users, the best Linux distro should be:

                    Easy to install - A simple installation process with graphical guidance.<br>
                    User-friendly interface - A desktop environment that resembles Windows or macOS for a smoother transition.
                    Good hardware support - Works well out of the box with minimal driver installation.<br>
                    Large software repository - Access to essential applications without complex commands.
                    Strong community support - Well-documented guides and active forums for troubleshooting.</p>
                
                <h1>Best Beginner-Friendly Linux Distros</h1>
                <p>If you're new to Linux, here are some of the best beginner-friendly distros to consider:<br>
                    <br>
                    1. Ubuntu<br>
                    
                    Why it's great for beginners:<br>
                    
                        One of the most popular Linux distributions.
                        Large community and extensive documentation.
                        Simple and intuitive user interface with GNOME desktop.
                        Great support for hardware and software.
                    
                    Best for: General users, students, and those looking for a widely supported and easy-to-use OS.<br>
                    <br>
                    2. Linux Mint<br>
                    
                    Why it's great for beginners:
                    
                        Windows-like interface, making it easy for new users to adapt.
                        Comes with essential software pre-installed.
                        Excellent hardware compatibility.
                        Multiple desktop environments to choose from (Cinnamon, MATE, Xfce).
                    
                    Best for: Users switching from Windows who want familiarity and ease of use.</p><br>
                <p>4. Pop!_OS<br>

                    Why it's great for beginners:
                    
                        Developed by System76, optimized for performance and ease of use.
                        Excellent support for gaming and productivity.
                        Automatic driver installation for NVIDIA and AMD users.
                        Clean and modern desktop experience.
                    
                    Best for: Gamers, content creators, and users with newer hardware.<br>
                    <br>
                    5. elementary OS<br>
                    
                    Why it's great for beginners:
                    
                        Beautiful and minimalist interface, similar to macOS.
                        Intuitive AppCenter for easy software installation.
                        Lightweight and smooth performance.
                        Privacy-focused and secure.
                    
                    Best for: macOS users looking for a sleek, simple, and elegant Linux experience.</p><br>
                <h1>Final Thoughts</h1>

                <p>Switching to a beginner-friendly Linux distro is a great way to explore a free, open-source operating
                    system without unnecessary complexity. Whether you choose Ubuntu, Linux Mint, Pop!_OS, or
                    elementary OS, each of these distros offers an easy and user-friendly experience for newcomers.<br>
                    
                    If youâ€™re ready to make the switch, pick a distro, install it, and enjoy the freedom and flexibility
                    of Linux!</p>

            </div>
        </section>
        <section id="home" class="hero">
            <div class="container">
                <h2>Git Guide Feb. 19, 2025</h2>
                <p>Setup using:
                    $ git config set --global user.name "Your Name"
                    $ git config set --global user.email "your-email@example.com"</p>
            
                    
                    <p>Basic Git Workflow:
                    1. Clone a remote repo.
                    2. Make some local changes.
                    3. Add those changes.
                    4. Commit changes.
                    5. Pull then push to the remote.
                    </p>
                    
                    <p>Origin is an alias for the remote repo. You can review your changes using
                    $ git diff or $ git diff --staged. Use
                    $ git restore or $ git restore --staged filename to restore a file.
                    To view commit history use
                    $ git log. The most recent is at the top of the list. HEAD is the default reference to the branch you're working on. When HEAD is no longer on the branch your working on it is known as detached. To reattach just use
                    $ git switch branch name.</p>
                    
                    <p>If two or more people are committing to the same branch, eventually git pull is going to have to merge. To tell git pull to always merge divergent branches with
                    $ git config set --global pull.rebase false. To make a new branch and switch to it
                    $ git switch newbranch.</p>
                    
                    <p>Merging branches:
                    $ git commit -m "finished"      // on topic branch
                    $ git switch main
                    $ git merge topic                     // merge topic into main
                    $ git branch -d topic               // delete branch
                    Force delete with -D in stead of -d "only if you know what your doing!"
                    </p>
                    
                    <p>Delete all remote tracking branches with
                    $ git fetch --prune
                    or
                    $ git fetch --prune someremote
                    and even
                    $ git fetch --prune --all
                    to delete everything.
                    </p>
                    
                    <p>There are four states files in git can be in:
                    Untracked, Unmodified, Modified, and Staged. here are some ways to change the states a file is in.
                    Untracked - git add foo.txt - Staged(as "new file")
                    Modified - git add foo.txt - Staged
                    Modified - git restore foo.txt - Unmodified
                    Unmodified - edit foo.txt - Modified(with your favourite editor)
                    Staged - git commit - Unmodified
                    Staged - git restore --staged - Modified
                    </p>
                    
                    <p>To find out the difference of modified file use:
                    $ git diff filename
                    diff rules:
                    If a line is prefixed with -, it means this is how the line was in the old version.
                    If a line is prefixed with +, It means this is how the line is in the new, modified version.
                    If a line is not prefixed with anything, it means it is unchanged between the versions.
                    If you just want a list of files that have changed, you can use the --name-only option.
                    To see what the diff between fileone and filetwo are use
                    $ git diff fileone...filetwo
                    </p>
                    
                    <p></p>Never rebase anything that you have pushed unless you know what your doing. Run git rebase --continue until all commits have been rebased cleanly. You can use git stash if you want to return your working tree to the state of the last commit. Once your done and want to get back to were you left off use git stash pop. 
                    $ git stash pushes the working tree on the stash stack.
                    $ git stash drop deletes a particular stash stack entry.
                    $ git stash list shows you the current stash stack.
                    $ git stash drop deletes a particular stash stack entry.
                    
                    It is a good idea to keep in sync with the upstream repo. Once you have the upstream remote set up, you have to sync running git fetch upstream then merge or rebase. You can use git reflog to get back to a commit you deleted.
                </p>
                    <p>Some common variable settings:
                        1.  user.name                          Your name
                        2. user.email                         Your email
                        3. pull.rebase                        set to true to try and rebase or false to try and merge
                        4. core.editor                        default commit message editor
                         
                        5. merge.tool            default merge tool (ex. meld)
                        6. diff.tool             default diff tool (ex. vimdiff)
                        7. difftool.prompt       Set to false to not launch your diff tool
                        8. color.ui              set to true for a colorful git output
                    
                    To edit the config file directly use
                    $ git config edit or $ git config --global
                    </p>
                    
                    <p>Creating aliases:
                    $ git config set --global alias.logn 'log --name-only'
                    Show all aliases 
                    $ git aliases
                    Change commit message
                    $ git commit -m "the new message"
                    </p>
                    
                    <p>Diff tools:
                    using vimdiff you can keep the changes or discard them 
                    :diffget LOCAL        keep changes
                    :diffget REMOTE     discard changes
                    
                    To not backup the original file/files use
                    $ git config --global set mergetool.keepBackup false
                    </p>
                    
                    <p>Using a repo with submodules:
                    To clone a repo and it's submodules use
                    $ git clone --recurse-submodules "repo address"
                    
                    The above command is for when you clone a new repo. Use these commands after the fact.
                    $ git clone "repo name"
                    $ cd "example-submodule"
                    $ git submodule update --recursive --init
                    
                    And there you have it, a git guide for new users. Thanks for reading and have a good day!</p>
                    </div>
    </main>

    <footer>
        <div class="container">
            <p>&copy; 2025 My Linux Blog. All rights reserved.</p>
        </div>
    </footer>
</body>
</html>